# React + D3.js 交互功能测试

本仓库中代码旨在对D3.js可视化库在React框架下的交互式应用进行尝试，并找到使两者高效结合，共同协作的一个可行解决方案。

## 问题概要

D3.js与React框架结合应用的主要问题在于D3.js需要对DOM节点的完全控制，然而React框架的设计哲学是尽可能避免对DOM的直接操作，因此两者在设计理念上存在不兼容之处。

虽然React具有JSX语法，看起来似乎是在JS中嵌入了类似HTML的DOM树，然而这些都是虚拟DOM节点，与实际渲染时的DOM不同，D3.js不能直接对这些虚拟DOM进行操作；因此，一般的解决方法是在React组件中给出一个DOM节点的引用（`ref`），让D3.js全权控制这个节点内部的部分，其他的部分还是由React框架处理。

这种做法实质上就是把一个D3.js实例套了一层React组件的封装，因为毕竟不是React组件的话是不能与整个框架相兼容的。但这时候就会出现一个大问题，就是要可视化的目标数据怎么传到D3.js手里。一般的思路肯定是上级组件把数据丢到封装着D3.js的外层React组件里面，然后React组件因为属性更改触发重渲染，在重渲染的生命周期方法里面把新的数据丢到D3.js控制的DOM节点里头去，相关的动效啥的也都能在这里头做。

这种方法一开始确实是好使的，对于类似React严格模式引起的二次渲染等问题也有处理办法。在早期React框架中对组件的类定义写法中，可以通过生命周期函数阻止数据、参数、状态变化引起的组件重复渲染，从而起到为D3.js屏蔽外部干扰的效果，通过这种方法可以使得D3.js在基于类组件的React应用中得到应用。

然而，最近新版本的React框架推荐基于钩子和函数式组件的写法，这之中并不提供严格的生命周期方法，只能使用钩子进行模拟，这又使得类似重复渲染的问题得不到解决了，但是又不能阻挡历史的进程和技术的发展，所以还是要研究一下函数式组件怎么和D3.js结合起来。

## 解决办法

经过一些尝试和研究，我发现一个相对有效的解决方案，不能直接把完整的D3.js绘图方法丢到受数据更新触发的`useEffect`钩子里面，这样会导致之前的图表不会擦除，新的图表会直接画在上面。虽然可以在绘图之前把之前的图给清了，但这样也不好做渐变动效，因为难以判断是初次渲染还是数据更新。

解决方案是把`useEffect`的依赖列表置空，即保证DOM只会被初始化1次，之后把需要随着数据变化产生动效的节点存到组件的`state`里面。之后另写一个受数据更新触发的`useEffect`钩子，在这里面只使用之前存下来的那些`state`来操作动效。由于React框架下直接在同一组件里的`useEffect`内部写`setState`会导致无限循环，因此我封装了一个钩子`useD3`用来包装原本的`useRef`和包含DOM初次绘制代码的`useEffect`，效果是不错的。

顺便，我给`useD3`钩子也预留了依赖列表，这个里面不是用来放数据的，而是放一些窗口参数，比如页面大小啊之类的，作用是为了可能的响应式适配，不过例子里面没体现这些就是了。

## 文件与功能

本仓库中有工程开发意义的文件基本都在`./src`目录下，其各自含义如下：

- `index.js`：前端应用入口点（根组件），包含切换展示图表的逻辑
- `index.css`：根组件的层叠样式表文档，没什么需要关注的
- `hooks.js`：封装了提供D3.js所需`<svg />`元素引用（`ref`）的钩子
- `InnerIC.js`：不与父组件有参数传递关系，所有交互操作完全包含在图表内部的图表组件（不受控）
- `OuterIC.js`：具有外部参数传入，并且父组件可以在外部对参数进行修改从而触发交互效果的组件（受控）
- `ZoomIC.js`：所需要展示的数据也完全依靠外部传入，需要在数据发生变化是触发平滑过渡切换，并且具有水平轴向缩放交互的组件（受控）

## 部署与运行

首先通过如下代码将此仓库克隆到本地，并在控制台将工作目录切换到仓库根目录下：

```
git clone https://github.com/seoi2017/d3-test.git
cd d3-text
```

确认您的计算机上拥有node.js运行时环境，之后如果您使用`npm`包管理器，可使用如下指令安装依赖：

```
npm install
```

如果您使用`yarn`包管理器，可使用如下指令安装依赖：

```
yarn
```

依赖安装完毕后，您可以使用`npm run start`或者`yarn start`命令启动前端测试环境，编译成功后您可以在浏览器中访问`http://localhost:3000`进行交互操作测试和观察图表形态。

## 测试场景说明

所有的三个图表都是从D3.js官方给出的Demo里面迁移过来的，更改为了适配React的版本，主要是为了测试各种交互和依赖数据更新触发的动效能不能正常工作。

`InnerIC.js`中封装的图表数据是内嵌的，没有外部的数据传入，也就没有受数据更改触发刷新的部分，其中只有D3.js控制下的内部交互，这里有个小问题就是和原本纯D3.js的实现版本相比，我这个React版本的动效感觉卡卡的，估计是哪里实现的不太好，但是目前还没找出原因来。

`OuterIC.js`中封装的图表数据也是内嵌的，也没有外部的数据传入，不过收到外部传入的一个参数控制数据展示的布局，切换布局时还要有渐变的动效，这是为了测试在图表在外界参数更新时不擦除重画而是基于初次绘图时存储的若干`state`来控制动效的效果，所有动效是用D3.js中的API实现的，没有React框架的介入。

`ZoomIC.js`稍微复杂一些，是两个测试的二合一，其中一个是zoom交互，也就是缩放，这个也是交给D3.js实现的，防止React插手；另一个是在数据完全依赖外部的情况下，如何处理数据更新时的动效问题。解决思路跟上面的没啥两样，跑起来也很正常，没啥问题。
